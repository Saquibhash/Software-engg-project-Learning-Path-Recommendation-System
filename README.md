IITM BS Degree Learning Path Recommendation System:

Problem Statement:-

A learning path recommendation based on both learning profile and feedback from previous term students can be a valuable tool for students. By taking into account student data from past enrollments, student performance and interests, as well as the feedback of other students who have taken similar courses, a learning path recommendation can help students identify the courses that are most likely to be beneficial to them. Such learning path recommendations can help students stay on track and make progress towards their educational goals. By providing students with a clear roadmap of the courses that they need to take, a learning path recommendation can help students pace themselves and avoid getting lost or sidetracked.
Here are some of the factors that should be considered when making a learning path recommendation:
Enrollment data from previous terms
The student's learning profile, including their past performance, interests, and goals.
The feedback of other students who have taken similar courses.
The student's schedule and other commitments.
The system should ideally have two users - an admin, and a student. An admin can load enrollment data from previous terms. The system should be able to infer patterns and provide recommendations to students. Students can also provide their feedback about past courses. The student can provide their learning profile, interests, goals, schedules and commitments, and the system should provide appropriate recommendations based on all the above inputs.
You are free to think creatively and come up with additional requirements or modify some of these requirements, as long as the overarching purpose of a learning path recommendation system is fulfilled.



THIS IS A GROUP PROJECT CONSISTING OF A TEAM OF 5 PEOPLE INCLUDING ME.
NAMES OF OTHER MEMBERS ARE AS FOLLOWS.

1.Chandana Nisankara

2.Dhanya K

3.Patil Dhairyasheel

4.Varun Sunderarajan

IITM IS THE PROPRIETER OF THIS GROUP PROJECT AND HOLD THE RIGHTS FOR THE DATA AND THIS IS REPO IS JUST FOR REFERENCE PURPOSE.


Technologies and Tools Used: Overall Development Process

● Git and Github: As asked in the problem statement, git was used as the very basis for the entire
project. Github repositories were used right from the very beginning, and milestone submissions were
made therein. The steps involved in git usage became second-nature to us by the end of the project.

● Postman: Postman was the go-to tool that we used for testing out API endpoints while building them.
The easy-to-use and feature-rich nature of Postman meant that we didn’t have to face much trouble in
testing and debugging our APIs.

● Visual Studio Code: It was the IDE of choice for all of us. It is quite powerful and its extensions were
very useful.

● Swagger OAS Editor: We’ve used Swagger to create and edit our API specification YAML document.

● Firefox, Safari, and Chrome:We used these browsers and their inbuilt developer consoles and
extensions while coding

● DB Browser for SQLite: It was used to manage the backend SQLite database during the development
and testing process.


Technologies and Tools Used: Frontend

Vue.js 3:Vue.js is an open-source JavaScript framework for building user interfaces and single-page
applications. It was used to create a functional application around our wireframes.

Bootstrap: Bootstrap was used throughout the entire app, styling purposes. Various Bootstrap elements,
such as buttons, tables, cards, etc. have been used.
HTML/CSS/JS: The basic tech stack for web pages

Technologies and Tools Used: Backend
● Python: The programming language that brought it all together. Almost 100% of the submissions as
part of our repository is Python code. Python-based frameworks like Flask were the basis for the
application. Various Python libraries, such as uuid, datetime, humanize, etc. were used.

● Flask: As mentioned in the problem statement, the Flask web framework was used for the backend
server. Various Flask sub-components, such as Flask-Security-Too (for the authentication mechanisms),
Flask-RESTful (for the API), Flask-CORS (for enabling cross-origin requests), etc. have been used. 

● SQLite: It was used as the database for storing the app data at the backend. Various tables corresponding
to the users, tickets, articles (FAQs), notifications, etc. were created

● SQLAlchemy: Flask-SQLAlchemy was used as the ORM to enable the interactions between the app at
the backend Flask API and the SQLite database. The various data models were made using the
appropriate classes in SQLAlchemy

